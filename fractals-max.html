<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Fractal Explorer</title>
    <script src="https://cdn.jsdelivr.net/npm/max-api@1.0.0/dist/max-api.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'SF Mono', 'Monaco', 'Consolas', monospace; color: #fff; }
        #canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }
        #controls {
            position: fixed; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.9); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px; padding: 15px; width: 340px; max-height: calc(100vh - 20px);
            overflow-y: auto; transition: transform 0.3s ease; z-index: 100;
        }
        #controls.hidden { transform: translateX(-360px); }
        #toggle-btn {
            position: fixed; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.85); border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px; color: #fff; padding: 10px 15px; cursor: pointer; z-index: 99; font-size: 12px;
        }
        #controls:not(.hidden) ~ #toggle-btn { left: 360px; }
        h2 { font-size: 14px; font-weight: 600; margin-bottom: 15px; color: #88f; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
        h3 { font-size: 11px; font-weight: 600; margin: 15px 0 8px 0; color: #8f8; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { margin-bottom: 10px; }
        label { display: block; font-size: 11px; color: #aaa; margin-bottom: 4px; }
        input[type="range"] { width: 100%; height: 4px; -webkit-appearance: none; background: rgba(255,255,255,0.1); border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #88f; border-radius: 50%; cursor: pointer; }
        input[type="number"], input[type="text"], select {
            width: 100%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px; color: #fff; padding: 6px 8px; font-family: inherit; font-size: 11px;
        }
        select option { background: #222; }
        button {
            background: rgba(136,136,255,0.3); border: 1px solid rgba(136,136,255,0.5);
            border-radius: 4px; color: #fff; padding: 8px 12px; cursor: pointer; font-size: 11px; margin: 2px;
        }
        button:hover { background: rgba(136,136,255,0.5); }
        .btn-row { display: flex; flex-wrap: wrap; gap: 4px; margin: 8px 0; }
        .value-display { font-size: 10px; color: #666; text-align: right; margin-top: 2px; }
        #info { position: fixed; bottom: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 4px; font-size: 10px; color: #888; z-index: 100; }
        #info .coord { color: #aaa; }
        #osc-status { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 4px; font-size: 11px; z-index: 100; }
        #osc-status.connected { color: #8f8; }
        #osc-status.disconnected { color: #f88; }
        #osc-status.max { color: #ff8; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; }
        .checkbox-group input[type="checkbox"] { width: 16px; height: 16px; }
        .param-section { display: none; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; padding: 10px; margin: 10px 0; background: rgba(255,255,255,0.02); }
        .param-section.active { display: block; }
        .param-section h4 { font-size: 10px; color: #f88; margin-bottom: 8px; text-transform: uppercase; }
        #keyboard-help { font-size: 9px; color: #555; margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); }
        #keyboard-help kbd { background: rgba(255,255,255,0.1); padding: 2px 5px; border-radius: 3px; margin-right: 3px; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <h2>üåÄ GPU Fractal Explorer</h2>
        
        <h3>Fractal Type</h3>
        <div class="control-group">
            <select id="fractalType">
                <option value="0">Mandelbrot</option>
                <option value="1">Burning Ship</option>
                <option value="2">Multibrot (z^d + c)</option>
                <option value="3">Newton Fractal</option>
                <option value="4">Clifford Attractor</option>
                <option value="5">Domain Coloring</option>
            </select>
        </div>
        
        <h3>Navigation</h3>
        <div class="control-group">
            <label>Center X</label>
            <input type="number" id="centerX" value="-0.5" step="0.0001">
        </div>
        <div class="control-group">
            <label>Center Y</label>
            <input type="number" id="centerY" value="0" step="0.0001">
        </div>
        <div class="control-group">
            <label>Zoom (log2)</label>
            <input type="range" id="zoom" min="-2" max="45" value="1" step="0.01">
            <div class="value-display" id="zoom-val">2x</div>
        </div>
        <div class="btn-row">
            <button id="reset-view">Reset View</button>
        </div>
        
        <h3>Rendering</h3>
        <div class="control-group">
            <label>Max Iterations</label>
            <input type="range" id="maxIter" min="50" max="5000" value="500" step="10">
            <div class="value-display" id="maxIter-val">500</div>
        </div>
        
        <!-- Escape-time params -->
        <div class="param-section active" id="params-escape">
            <h4>Julia Mode</h4>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="juliaMode">
                <label>Enable Julia Set</label>
            </div>
            <div class="control-group">
                <label>Julia C (Real)</label>
                <input type="range" id="juliaX" min="-2" max="2" value="-0.7" step="0.001">
                <div class="value-display" id="juliaX-val">-0.700</div>
            </div>
            <div class="control-group">
                <label>Julia C (Imag)</label>
                <input type="range" id="juliaY" min="-2" max="2" value="0.27" step="0.001">
                <div class="value-display" id="juliaY-val">0.270</div>
            </div>
            <div class="btn-row">
                <button class="julia-preset" data-x="0" data-y="1">Dendrite</button>
                <button class="julia-preset" data-x="-0.123" data-y="0.745">Rabbit</button>
                <button class="julia-preset" data-x="-0.8" data-y="0.156">Dragon</button>
            </div>
        </div>
        
        <!-- Multibrot power -->
        <div class="param-section" id="params-multibrot">
            <h4>Multibrot Power</h4>
            <div class="control-group">
                <label>Power (d)</label>
                <input type="range" id="multibrotPower" min="2" max="8" value="2" step="0.01">
                <div class="value-display" id="multibrotPower-val">2.00</div>
            </div>
        </div>
        
        <!-- Newton params -->
        <div class="param-section" id="params-newton">
            <h4>Newton Fractal</h4>
            <div class="control-group">
                <label>Polynomial</label>
                <select id="newtonPoly">
                    <option value="0">z¬≥ - 1</option>
                    <option value="1">z‚Å¥ - 1</option>
                    <option value="2">z‚Åµ - 1</option>
                    <option value="3">z‚Å∂ - 1</option>
                </select>
            </div>
            <div class="control-group">
                <label>Relaxation</label>
                <input type="range" id="newtonRelax" min="0.1" max="2" value="1" step="0.01">
                <div class="value-display" id="newtonRelax-val">1.00</div>
            </div>
        </div>
        
        <!-- Clifford params -->
        <div class="param-section" id="params-clifford">
            <h4>Clifford Attractor</h4>
            <div class="control-group">
                <label>a</label>
                <input type="range" id="cliffordA" min="-3" max="3" value="-1.4" step="0.001">
                <div class="value-display" id="cliffordA-val">-1.400</div>
            </div>
            <div class="control-group">
                <label>b</label>
                <input type="range" id="cliffordB" min="-3" max="3" value="1.6" step="0.001">
                <div class="value-display" id="cliffordB-val">1.600</div>
            </div>
            <div class="control-group">
                <label>c</label>
                <input type="range" id="cliffordC" min="-3" max="3" value="1.0" step="0.001">
                <div class="value-display" id="cliffordC-val">1.000</div>
            </div>
            <div class="control-group">
                <label>d</label>
                <input type="range" id="cliffordD" min="-3" max="3" value="0.7" step="0.001">
                <div class="value-display" id="cliffordD-val">0.700</div>
            </div>
            <div class="btn-row">
                <button class="clifford-preset" data-a="-1.4" data-b="1.6" data-c="1.0" data-d="0.7">Classic</button>
                <button class="clifford-preset" data-a="1.7" data-b="1.7" data-c="0.6" data-d="1.2">Leaf</button>
                <button class="clifford-preset" data-a="-1.7" data-b="1.3" data-c="-0.1" data-d="-1.2">Swirl</button>
            </div>
        </div>
        
        <!-- Domain coloring params -->
        <div class="param-section" id="params-domain">
            <h4>Complex Function</h4>
            <div class="control-group">
                <label>Function f(z)</label>
                <select id="domainFunc">
                    <option value="0">z</option>
                    <option value="1">z¬≤</option>
                    <option value="2">z¬≥</option>
                    <option value="3">1/z</option>
                    <option value="4">sin(z)</option>
                    <option value="5">cos(z)</option>
                    <option value="6">exp(z)</option>
                    <option value="7">tan(z)</option>
                    <option value="8">(z¬≤-1)/(z¬≤+1)</option>
                    <option value="9">z + 1/z</option>
                </select>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="domainGrid" checked>
                <label>Show Grid</label>
            </div>
        </div>
        
        <h3>Colors</h3>
        <div class="control-group">
            <label>Color Scheme</label>
            <select id="colorScheme">
                <option value="0">Classic</option>
                <option value="1">Fire</option>
                <option value="2">Ocean</option>
                <option value="3">Rainbow</option>
                <option value="4">Grayscale</option>
                <option value="5">Psychedelic</option>
                <option value="6">Electric</option>
            </select>
        </div>
        <div class="control-group">
            <label>Color Offset</label>
            <input type="range" id="colorOffset" min="0" max="1" value="0" step="0.001">
            <div class="value-display" id="colorOffset-val">0.000</div>
        </div>
        <div class="control-group">
            <label>Color Frequency</label>
            <input type="range" id="colorFreq" min="0.1" max="10" value="1" step="0.1">
            <div class="value-display" id="colorFreq-val">1.0</div>
        </div>
        
        <h3>Animation</h3>
        <div class="control-group checkbox-group">
            <input type="checkbox" id="autoZoom">
            <label>Auto Zoom</label>
        </div>
        <div class="control-group checkbox-group">
            <input type="checkbox" id="colorCycle">
            <label>Color Cycle</label>
        </div>
        <div class="control-group checkbox-group">
            <input type="checkbox" id="animateParams">
            <label>Animate Parameters</label>
        </div>
        <div class="control-group">
            <label>Animation Speed</label>
            <input type="range" id="animSpeed" min="0.1" max="3" value="1" step="0.1">
            <div class="value-display" id="animSpeed-val">1.0</div>
        </div>
        
        <h3>OSC Control</h3>
        <div class="control-group">
            <label>WebSocket URL</label>
            <input type="text" id="wsUrl" value="ws://localhost:8080">
        </div>
        <div class="btn-row">
            <button id="osc-connect">Connect</button>
            <button id="osc-disconnect">Disconnect</button>
        </div>
        
        <h3>Sonification Analysis</h3>
        <div class="control-group">
            <label>Analysis Rate (fps)</label>
            <input type="range" id="analysisRate" min="1" max="60" value="30" step="1">
            <div class="value-display" id="analysisRate-val">30</div>
        </div>
        <div class="control-group">
            <label>Grid Size</label>
            <select id="analysisGridSize">
                <option value="4">4√ó4 (16)</option>
                <option value="8" selected>8√ó8 (64)</option>
                <option value="16">16√ó16 (256)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Ring Samples</label>
            <select id="analysisRingSamples">
                <option value="8">8</option>
                <option value="16" selected>16</option>
                <option value="32">32</option>
                <option value="64">64</option>
            </select>
        </div>
        
        <div class="param-section active" id="params-analysis">
            <h4>Output Channels</h4>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anBrightness" checked>
                <label>Brightness (avg luminance)</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anEscapeRatio" checked>
                <label>Escape Ratio (set density)</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anEdgeDensity" checked>
                <label>Edge Density (boundary)</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anDominantHue">
                <label>Dominant Hue</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anColorBalance">
                <label>Color Balance (RGB)</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anSpectralCentroid">
                <label>Spectral Centroid</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anGrid">
                <label>Spatial Grid</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anColumnSums">
                <label>Column Sums (spectrogram)</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anRowSums">
                <label>Row Sums (waveform)</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anRing">
                <label>Ring Sample (radial)</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anIterHist">
                <label>Iteration Histogram</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anZoomParams">
                <label>Zoom/Position Params</label>
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="anFractalParams">
                <label>Current Fractal Params</label>
            </div>
        </div>
        
        <div id="analysis-monitor" style="font-size:9px; color:#666; margin-top:10px; max-height:100px; overflow-y:auto; font-family:monospace;">
            <div id="analysis-output"></div>
        </div>
        
        <div id="keyboard-help">
            <kbd>H</kbd> UI <kbd>R</kbd> Reset <kbd>J</kbd> Julia <kbd>Space</kbd> Zoom <kbd>C</kbd> Colors <kbd>1-6</kbd> Type
        </div>
    </div>
    
    <button id="toggle-btn">‚ò∞</button>
    
    <div id="info">
        <div>Fractal: <span class="coord" id="fractal-display">Mandelbrot</span></div>
        <div>Position: <span class="coord" id="pos-display">(-0.5, 0)</span></div>
        <div>Zoom: <span class="coord" id="zoom-display">2x</span></div>
        <div>FPS: <span class="coord" id="fps-display">60</span></div>
    </div>
    
    <div id="osc-status" class="disconnected">OSC: Disconnected</div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2', { antialias: false, preserveDrawingBuffer: true, powerPreference: 'high-performance' });
        if (!gl) { alert('WebGL2 required'); throw new Error('No WebGL2'); }
        
        // Check for float texture support (needed for Clifford)
        const floatTexExt = gl.getExtension('EXT_color_buffer_float');
        if (!floatTexExt) console.warn('EXT_color_buffer_float not available - Clifford may have reduced quality');

        // Vertex shader
        const vsSource = `#version 300 es
            in vec2 a_pos;
            out vec2 v_uv;
            void main() { v_uv = a_pos * 0.5 + 0.5; gl_Position = vec4(a_pos, 0.0, 1.0); }
        `;

        // Fragment shader with all fractals
        const fsSource = `#version 300 es
            precision highp float;
            in vec2 v_uv;
            out vec4 fragColor;
            
            uniform vec2 u_res;
            uniform vec2 u_center;
            uniform float u_zoom;
            uniform int u_maxIter;
            uniform int u_type;
            uniform int u_colorScheme;
            uniform float u_colorOffset;
            uniform float u_colorFreq;
            uniform float u_time;
            
            // Escape fractals
            uniform bool u_julia;
            uniform vec2 u_juliaC;
            uniform float u_power;
            
            // Newton
            uniform int u_newtonPoly;
            uniform float u_newtonRelax;
            
            // Clifford
            uniform float u_cA, u_cB, u_cC, u_cD;
            uniform sampler2D u_cliffordTex;
            
            // Domain
            uniform int u_domainFunc;
            uniform bool u_domainGrid;
            
            #define PI 3.14159265359
            #define TAU 6.28318530718
            
            vec3 palette(float t, int s) {
                t = fract(t);
                if (s == 0) return vec3(0.5 + 0.5*cos(TAU*(t+0.0)), 0.5 + 0.5*cos(TAU*(t+0.33)), 0.5 + 0.5*cos(TAU*(t+0.67)));
                if (s == 1) return vec3(smoothstep(0.0,0.5,t), smoothstep(0.25,0.75,t)*0.7, smoothstep(0.5,1.0,t)*0.3);
                if (s == 2) return vec3(0.1+0.2*sin(TAU*t), 0.3+0.4*sin(TAU*(t+0.25)), 0.5+0.5*sin(TAU*(t+0.5)));
                if (s == 3) { float h=t*6.0; float x=1.0-abs(mod(h,2.0)-1.0); if(h<1.)return vec3(1,x,0); if(h<2.)return vec3(x,1,0); if(h<3.)return vec3(0,1,x); if(h<4.)return vec3(0,x,1); if(h<5.)return vec3(x,0,1); return vec3(1,0,x); }
                if (s == 4) { float v=0.5+0.5*sin(TAU*t); return vec3(v); }
                if (s == 5) return vec3(0.5+0.5*sin(TAU*t*3.0), 0.5+0.5*sin(TAU*t*5.0+2.0), 0.5+0.5*sin(TAU*t*7.0+4.0));
                return vec3(pow(t,0.5), 0.2+0.8*pow(sin(PI*t),2.0), 1.0-pow(1.0-t,2.0));
            }
            
            vec2 cmul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }
            vec2 cdiv(vec2 a, vec2 b) { float d=dot(b,b); return d > 1e-10 ? vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y)/d : vec2(0.0); }
            vec2 cpow(vec2 z, float n) { float r=length(z); if(r < 1e-10) return vec2(0.0); float th=atan(z.y,z.x); return pow(r,n)*vec2(cos(n*th),sin(n*th)); }
            vec2 cexp(vec2 z) { return exp(z.x)*vec2(cos(z.y),sin(z.y)); }
            vec2 csin(vec2 z) { return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y)); }
            vec2 ccos(vec2 z) { return vec2(cos(z.x)*cosh(z.y), -sin(z.x)*sinh(z.y)); }
            vec2 ctan(vec2 z) { return cdiv(csin(z), ccos(z)); }
            
            vec3 mandelbrot(vec2 coord) {
                vec2 c = u_julia ? u_juliaC : coord;
                vec2 z = u_julia ? coord : vec2(0.0);
                int iter = 0;
                for (int i = 0; i < 10000; i++) {
                    if (i >= u_maxIter) break;
                    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                    if (dot(z,z) > 256.0) break;
                    iter++;
                }
                if (iter >= u_maxIter) return vec3(0.0);
                float sm = float(iter) - log2(log2(dot(z,z))) + 4.0;
                return palette(sm * u_colorFreq / 100.0 + u_colorOffset, u_colorScheme);
            }
            
            vec3 burningShip(vec2 coord) {
                vec2 c = u_julia ? u_juliaC : coord;
                vec2 z = u_julia ? coord : vec2(0.0);
                int iter = 0;
                for (int i = 0; i < 10000; i++) {
                    if (i >= u_maxIter) break;
                    z = abs(z);
                    z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                    if (dot(z,z) > 256.0) break;
                    iter++;
                }
                if (iter >= u_maxIter) return vec3(0.0);
                float sm = float(iter) - log2(log2(dot(z,z))) + 4.0;
                return palette(sm * u_colorFreq / 100.0 + u_colorOffset, u_colorScheme);
            }
            
            vec3 multibrot(vec2 coord) {
                vec2 c = u_julia ? u_juliaC : coord;
                vec2 z = u_julia ? coord : vec2(0.0);
                int iter = 0;
                for (int i = 0; i < 10000; i++) {
                    if (i >= u_maxIter) break;
                    z = cpow(z, u_power) + c;
                    if (dot(z,z) > 256.0) break;
                    iter++;
                }
                if (iter >= u_maxIter) return vec3(0.0);
                float logPower = log(max(u_power, 1.001));
                float sm = float(iter) - log(log(dot(z,z))/log(256.0))/logPower;
                return palette(sm * u_colorFreq / 100.0 + u_colorOffset, u_colorScheme);
            }
            
            vec3 newton(vec2 coord) {
                vec2 z = coord;
                int n = u_newtonPoly + 3;
                float tol = 1e-6;
                int iter = 0;
                
                for (int i = 0; i < 10000; i++) {
                    if (i >= u_maxIter) break;
                    vec2 zn = cpow(z, float(n));
                    vec2 zn1 = cpow(z, float(n-1));
                    vec2 f = zn - vec2(1.0, 0.0);
                    vec2 df = float(n) * zn1;
                    if (dot(df, df) < 1e-10) break; // Avoid division by zero
                    vec2 step = cdiv(f, df);
                    z = z - u_newtonRelax * step;
                    if (dot(step,step) < tol*tol) break;
                    iter++;
                }
                
                float angle = atan(z.y, z.x);
                int root = int(floor((angle/TAU + 0.5) * float(n) + 0.5));
                float hue = float(root) / float(n) + u_colorOffset;
                float bright = 1.0 - float(iter) * u_colorFreq / float(u_maxIter);
                return palette(hue, u_colorScheme) * clamp(bright, 0.3, 1.0);
            }
            
            vec3 clifford(vec2 coord) {
                vec2 uv = (coord - u_center) * u_zoom * 0.15 + 0.5;
                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return vec3(0.0);
                float d = texture(u_cliffordTex, uv).r;
                float t = log(1.0 + d * 50.0) / 4.0 + u_colorOffset;
                return palette(t, u_colorScheme) * sqrt(d * 5.0);
            }
            
            vec3 domainColor(vec2 coord) {
                vec2 z = coord;
                vec2 fz;
                if (u_domainFunc == 0) fz = z;
                else if (u_domainFunc == 1) fz = cmul(z,z);
                else if (u_domainFunc == 2) fz = cmul(cmul(z,z),z);
                else if (u_domainFunc == 3) fz = cdiv(vec2(1,0), z);
                else if (u_domainFunc == 4) fz = csin(z);
                else if (u_domainFunc == 5) fz = ccos(z);
                else if (u_domainFunc == 6) fz = cexp(z);
                else if (u_domainFunc == 7) fz = ctan(z);
                else if (u_domainFunc == 8) fz = cdiv(cmul(z,z)-vec2(1,0), cmul(z,z)+vec2(1,0));
                else fz = z + cdiv(vec2(1,0), z);
                
                float hue = atan(fz.y, fz.x) / TAU + 0.5 + u_colorOffset;
                float mag = length(fz);
                float val = 0.5 + 0.5 * sin(log2(mag + 1.0) * PI * u_colorFreq);
                
                if (u_domainGrid) {
                    float gx = abs(fract(fz.x) - 0.5);
                    float gy = abs(fract(fz.y) - 0.5);
                    if (gx < 0.03 || gy < 0.03) val *= 0.7;
                }
                
                return palette(hue, u_colorScheme) * val;
            }
            
            void main() {
                float aspect = u_res.x / u_res.y;
                vec2 uv = v_uv * 2.0 - 1.0;
                uv.x *= aspect;
                vec2 coord = uv / u_zoom + u_center;
                
                vec3 color;
                if (u_type == 0) color = mandelbrot(coord);
                else if (u_type == 1) color = burningShip(coord);
                else if (u_type == 2) color = multibrot(coord);
                else if (u_type == 3) color = newton(coord);
                else if (u_type == 4) color = clifford(coord);
                else color = domainColor(coord);
                
                fragColor = vec4(color, 1.0);
            }
        `;

        function createShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) { console.error(gl.getShaderInfoLog(s)); return null; }
            return s;
        }

        const vs = createShader(gl.VERTEX_SHADER, vsSource);
        const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            console.error('Shader link error:', gl.getProgramInfoLog(prog));
        }

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);

        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        const posLoc = gl.getAttribLocation(prog, 'a_pos');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const u = {};
        ['res','center','zoom','maxIter','type','colorScheme','colorOffset','colorFreq','time',
         'julia','juliaC','power','newtonPoly','newtonRelax','cA','cB','cC','cD','cliffordTex',
         'domainFunc','domainGrid'].forEach(n => u[n] = gl.getUniformLocation(prog, 'u_'+n));

        const clifSize = 2048;
        const clifTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, clifTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, clifSize, clifSize, 0, gl.RED, gl.FLOAT, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // =====================================================
        // STATE
        // =====================================================
        const state = {
            type: 0, centerX: -0.5, centerY: 0, zoom: 1,
            maxIter: 500, colorScheme: 0, colorOffset: 0, colorFreq: 1,
            juliaMode: false, juliaX: -0.7, juliaY: 0.27,
            multibrotPower: 2, newtonPoly: 0, newtonRelax: 1,
            cliffordA: -1.4, cliffordB: 1.6, cliffordC: 1.0, cliffordD: 0.7, cliffordDirty: true,
            domainFunc: 4, domainGrid: true,
            autoZoom: false, colorCycle: false, animateParams: false, animSpeed: 1
        };
        
        // =====================================================
        // ANALYSIS STATE
        // =====================================================
        const analysis = {
            // Configuration
            rate: 30,           // Analysis rate in fps
            gridSize: 8,        // NxN grid
            ringSamples: 16,    // Samples around ring
            
            // Toggles for each output channel
            channels: {
                brightness: true,
                escapeRatio: true,
                edgeDensity: true,
                dominantHue: false,
                colorBalance: false,
                spectralCentroid: false,
                grid: false,
                columnSums: false,
                rowSums: false,
                ring: false,
                iterHist: false,
                zoomParams: false,
                fractalParams: false
            },
            
            // Last computed values (for display/smoothing)
            values: {},
            
            // Timing
            lastAnalysisTime: 0,
            analysisInterval: 1000 / 30
        };
        
        // Analysis framebuffer for efficient GPU readback
        const analysisResolution = 128; // Fixed low-res for analysis
        const analysisFBO = gl.createFramebuffer();
        const analysisTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, analysisTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, analysisResolution, analysisResolution, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.bindFramebuffer(gl.FRAMEBUFFER, analysisFBO);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, analysisTexture, 0);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        const names = ['Mandelbrot', 'Burning Ship', 'Multibrot', 'Newton', 'Clifford', 'Domain'];
        const defaults = [
            {x:-0.5,y:0,z:1}, {x:-0.4,y:-0.6,z:1}, {x:0,y:0,z:0.5}, 
            {x:0,y:0,z:0.5}, {x:0,y:0,z:0.3}, {x:0,y:0,z:0.5}
        ];

        // Throttle Clifford computation to avoid stuttering during animation
        let cliffordTimeout = null;
        function scheduleClifordCompute() {
            if (cliffordTimeout) return;
            cliffordTimeout = setTimeout(() => {
                computeClifford();
                cliffordTimeout = null;
            }, 50);
        }

        function computeClifford() {
            const {cliffordA:a, cliffordB:b, cliffordC:c, cliffordD:d} = state;
            const data = new Float32Array(clifSize * clifSize);
            let x = 0.1, y = 0.1;
            // Warmup iterations
            for (let i = 0; i < 1000; i++) { 
                const nx = Math.sin(a*y) + c*Math.cos(a*x); 
                const ny = Math.sin(b*x) + d*Math.cos(b*y); 
                x = nx; y = ny; 
            }
            // Main iteration
            for (let i = 0; i < 2000000; i++) {
                const nx = Math.sin(a*y) + c*Math.cos(a*x); 
                const ny = Math.sin(b*x) + d*Math.cos(b*y); 
                x = nx; y = ny;
                const px = Math.floor(x * clifSize/6 + clifSize/2); 
                const py = Math.floor(y * clifSize/6 + clifSize/2);
                if (px >= 0 && px < clifSize && py >= 0 && py < clifSize) {
                    data[py * clifSize + px] += 0.1;
                }
            }
            gl.bindTexture(gl.TEXTURE_2D, clifTex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.R32F, clifSize, clifSize, 0, gl.RED, gl.FLOAT, data);
            state.cliffordDirty = false;
        }

        // =====================================================
        // SONIFICATION ANALYSIS SYSTEM
        // =====================================================
        
        // Render to low-res analysis buffer
        function renderAnalysisBuffer() {
            gl.bindFramebuffer(gl.FRAMEBUFFER, analysisFBO);
            gl.viewport(0, 0, analysisResolution, analysisResolution);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            const pixels = new Uint8Array(analysisResolution * analysisResolution * 4);
            gl.readPixels(0, 0, analysisResolution, analysisResolution, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            
            return pixels;
        }
        
        // Compute all enabled analysis channels
        function computeAnalysis(pixels) {
            const w = analysisResolution, h = analysisResolution;
            const n = w * h;
            const results = {};
            const ch = analysis.channels;
            
            // Pre-compute common values if any channel needs them
            let totalR = 0, totalG = 0, totalB = 0, totalBrightness = 0;
            let escapeCount = 0;
            const needsBasic = ch.brightness || ch.escapeRatio || ch.dominantHue || ch.colorBalance || ch.spectralCentroid;
            
            if (needsBasic) {
                for (let i = 0; i < pixels.length; i += 4) {
                    const r = pixels[i], g = pixels[i+1], b = pixels[i+2];
                    totalR += r; totalG += g; totalB += b;
                    const lum = (r + g + b) / 3;
                    totalBrightness += lum;
                    if (r + g + b > 15) escapeCount++;
                }
            }
            
            // === Brightness (0-1) ===
            if (ch.brightness) {
                results.brightness = totalBrightness / n / 255;
            }
            
            // === Escape Ratio (0-1) - density of non-set pixels ===
            if (ch.escapeRatio) {
                results.escapeRatio = escapeCount / n;
            }
            
            // === Dominant Hue (0-1) ===
            if (ch.dominantHue) {
                const r = totalR / n, g = totalG / n, b = totalB / n;
                results.dominantHue = rgbToHue(r, g, b);
            }
            
            // === Color Balance (RGB array, each 0-1) ===
            if (ch.colorBalance) {
                results.colorBalance = [
                    totalR / n / 255,
                    totalG / n / 255,
                    totalB / n / 255
                ];
            }
            
            // === Spectral Centroid (brightness-weighted position, 0-1) ===
            if (ch.spectralCentroid) {
                let weightedX = 0, weightedY = 0, totalWeight = 0;
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const i = (y * w + x) * 4;
                        const lum = (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
                        weightedX += x * lum;
                        weightedY += y * lum;
                        totalWeight += lum;
                    }
                }
                if (totalWeight > 0) {
                    results.spectralCentroid = [
                        weightedX / totalWeight / w,
                        weightedY / totalWeight / h
                    ];
                } else {
                    results.spectralCentroid = [0.5, 0.5];
                }
            }
            
            // === Edge Density (0-1) ===
            if (ch.edgeDensity) {
                let edgeCount = 0;
                const threshold = 30;
                for (let y = 1; y < h - 1; y++) {
                    for (let x = 1; x < w - 1; x++) {
                        const i = (y * w + x) * 4;
                        const c = pixels[i] + pixels[i+1] + pixels[i+2];
                        const l = pixels[i-4] + pixels[i-3] + pixels[i-2];
                        const r = pixels[i+4] + pixels[i+5] + pixels[i+6];
                        const t = pixels[i-w*4] + pixels[i-w*4+1] + pixels[i-w*4+2];
                        const b = pixels[i+w*4] + pixels[i+w*4+1] + pixels[i+w*4+2];
                        const dx = Math.abs(r - l);
                        const dy = Math.abs(b - t);
                        if (dx > threshold || dy > threshold) edgeCount++;
                    }
                }
                results.edgeDensity = edgeCount / ((w-2) * (h-2));
            }
            
            // === Spatial Grid (NxN array of brightness values) ===
            if (ch.grid) {
                const gs = analysis.gridSize;
                const cellW = Math.floor(w / gs);
                const cellH = Math.floor(h / gs);
                const grid = [];
                for (let gy = 0; gy < gs; gy++) {
                    for (let gx = 0; gx < gs; gx++) {
                        let sum = 0, count = 0;
                        for (let y = gy * cellH; y < (gy + 1) * cellH && y < h; y++) {
                            for (let x = gx * cellW; x < (gx + 1) * cellW && x < w; x++) {
                                const i = (y * w + x) * 4;
                                sum += (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
                                count++;
                            }
                        }
                        grid.push(count > 0 ? sum / count / 255 : 0);
                    }
                }
                results.grid = grid;
            }
            
            // === Column Sums (width values - good for spectrogram-like output) ===
            if (ch.columnSums) {
                const cols = [];
                for (let x = 0; x < w; x++) {
                    let sum = 0;
                    for (let y = 0; y < h; y++) {
                        const i = (y * w + x) * 4;
                        sum += (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
                    }
                    cols.push(sum / h / 255);
                }
                results.columnSums = cols;
            }
            
            // === Row Sums (height values - good for waveform-like output) ===
            if (ch.rowSums) {
                const rows = [];
                for (let y = 0; y < h; y++) {
                    let sum = 0;
                    for (let x = 0; x < w; x++) {
                        const i = (y * w + x) * 4;
                        sum += (pixels[i] + pixels[i+1] + pixels[i+2]) / 3;
                    }
                    rows.push(sum / w / 255);
                }
                results.rowSums = rows;
            }
            
            // === Ring Sample (radial samples around center) ===
            if (ch.ring) {
                const samples = analysis.ringSamples;
                const ring = [];
                const cx = w / 2, cy = h / 2;
                const radius = Math.min(w, h) * 0.4;
                for (let i = 0; i < samples; i++) {
                    const angle = (i / samples) * Math.PI * 2;
                    const sx = Math.floor(cx + Math.cos(angle) * radius);
                    const sy = Math.floor(cy + Math.sin(angle) * radius);
                    if (sx >= 0 && sx < w && sy >= 0 && sy < h) {
                        const pi = (sy * w + sx) * 4;
                        ring.push((pixels[pi] + pixels[pi+1] + pixels[pi+2]) / 3 / 255);
                    } else {
                        ring.push(0);
                    }
                }
                results.ring = ring;
            }
            
            // === Iteration Histogram (requires CPU recomputation for escape-time fractals) ===
            if (ch.iterHist && state.type <= 2) {
                const bins = 16;
                const hist = new Array(bins).fill(0);
                const aspect = canvas.width / canvas.height;
                const scale = 1 / Math.pow(2, state.zoom);
                const sampleCount = 256; // Sample points
                
                for (let i = 0; i < sampleCount; i++) {
                    // Sample in a grid pattern
                    const sx = (i % 16) / 16 * 2 - 1;
                    const sy = Math.floor(i / 16) / 16 * 2 - 1;
                    const cx = sx * aspect * scale + state.centerX;
                    const cy = sy * scale + state.centerY;
                    
                    const iter = computeIteration(cx, cy, state.maxIter, state.type);
                    const bin = Math.min(bins - 1, Math.floor(iter / state.maxIter * bins));
                    hist[bin]++;
                }
                
                // Normalize
                results.iterHist = hist.map(v => v / sampleCount);
            }
            
            // === Zoom/Position Parameters ===
            if (ch.zoomParams) {
                results.zoomParams = {
                    zoom: state.zoom / 45, // Normalized 0-1
                    zoomRaw: state.zoom,
                    centerX: (state.centerX + 2) / 4, // Roughly normalized
                    centerY: (state.centerY + 2) / 4,
                    scale: Math.pow(2, state.zoom)
                };
            }
            
            // === Current Fractal Parameters ===
            if (ch.fractalParams) {
                results.fractalParams = {
                    type: state.type,
                    colorScheme: state.colorScheme,
                    colorOffset: state.colorOffset,
                    colorFreq: state.colorFreq,
                    juliaMode: state.juliaMode ? 1 : 0,
                    juliaX: state.juliaX,
                    juliaY: state.juliaY,
                    power: state.multibrotPower,
                    newtonRelax: state.newtonRelax
                };
            }
            
            return results;
        }
        
        // CPU iteration computation for histogram
        function computeIteration(cx, cy, maxIter, type) {
            let zx = state.juliaMode ? cx : 0;
            let zy = state.juliaMode ? cy : 0;
            const jcx = state.juliaMode ? state.juliaX : cx;
            const jcy = state.juliaMode ? state.juliaY : cy;
            
            for (let i = 0; i < maxIter; i++) {
                let zx2, zy2;
                if (type === 1) { // Burning Ship
                    zx = Math.abs(zx);
                    zy = Math.abs(zy);
                }
                zx2 = zx * zx;
                zy2 = zy * zy;
                if (zx2 + zy2 > 4) return i;
                zy = 2 * zx * zy + jcy;
                zx = zx2 - zy2 + jcx;
            }
            return maxIter;
        }
        
        // RGB to Hue conversion
        function rgbToHue(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            if (max === min) return 0;
            let h;
            const d = max - min;
            if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
            else if (max === g) h = ((b - r) / d + 2) / 6;
            else h = ((r - g) / d + 4) / 6;
            return h;
        }
        
        // Output analysis results via OSC/Max
        function outputAnalysis(results) {
            const messages = [];
            
            // Single values
            if (results.brightness !== undefined) {
                messages.push({ address: '/fractal/analysis/brightness', args: [results.brightness] });
            }
            if (results.escapeRatio !== undefined) {
                messages.push({ address: '/fractal/analysis/escapeRatio', args: [results.escapeRatio] });
            }
            if (results.edgeDensity !== undefined) {
                messages.push({ address: '/fractal/analysis/edgeDensity', args: [results.edgeDensity] });
            }
            if (results.dominantHue !== undefined) {
                messages.push({ address: '/fractal/analysis/dominantHue', args: [results.dominantHue] });
            }
            
            // Arrays
            if (results.colorBalance) {
                messages.push({ address: '/fractal/analysis/colorBalance', args: results.colorBalance });
            }
            if (results.spectralCentroid) {
                messages.push({ address: '/fractal/analysis/spectralCentroid', args: results.spectralCentroid });
            }
            if (results.grid) {
                messages.push({ address: '/fractal/analysis/grid', args: results.grid });
            }
            if (results.columnSums) {
                messages.push({ address: '/fractal/analysis/columnSums', args: results.columnSums });
            }
            if (results.rowSums) {
                messages.push({ address: '/fractal/analysis/rowSums', args: results.rowSums });
            }
            if (results.ring) {
                messages.push({ address: '/fractal/analysis/ring', args: results.ring });
            }
            if (results.iterHist) {
                messages.push({ address: '/fractal/analysis/iterHist', args: results.iterHist });
            }
            
            // Objects (flatten for OSC)
            if (results.zoomParams) {
                const zp = results.zoomParams;
                messages.push({ address: '/fractal/analysis/zoom', args: [zp.zoom] });
                messages.push({ address: '/fractal/analysis/zoomRaw', args: [zp.zoomRaw] });
                messages.push({ address: '/fractal/analysis/position', args: [zp.centerX, zp.centerY] });
            }
            if (results.fractalParams) {
                const fp = results.fractalParams;
                messages.push({ address: '/fractal/analysis/fractalType', args: [fp.type] });
                messages.push({ address: '/fractal/analysis/julia', args: [fp.juliaMode, fp.juliaX, fp.juliaY] });
            }
            
            // Send via Max API
            if (window.max) {
                for (const msg of messages) {
                    const addr = msg.address.replace('/fractal/analysis/', '');
                    window.max.outlet('analysis', addr, ...msg.args);
                }
            }
            
            // Send via WebSocket (for OSC bridge to forward)
            if (ws && ws.readyState === 1) {
                for (const msg of messages) {
                    ws.send(JSON.stringify({ type: 'analysis', ...msg }));
                }
            }
            
            // Update monitor display
            updateAnalysisMonitor(results);
            
            // Store for external access
            analysis.values = results;
        }
        
        // Update the analysis monitor in the UI
        function updateAnalysisMonitor(results) {
            const el = document.getElementById('analysis-output');
            if (!el) return;
            
            const lines = [];
            if (results.brightness !== undefined) lines.push(`brightness: ${results.brightness.toFixed(3)}`);
            if (results.escapeRatio !== undefined) lines.push(`escape: ${results.escapeRatio.toFixed(3)}`);
            if (results.edgeDensity !== undefined) lines.push(`edges: ${results.edgeDensity.toFixed(3)}`);
            if (results.dominantHue !== undefined) lines.push(`hue: ${results.dominantHue.toFixed(3)}`);
            if (results.colorBalance) lines.push(`rgb: ${results.colorBalance.map(v => v.toFixed(2)).join(', ')}`);
            if (results.spectralCentroid) lines.push(`centroid: ${results.spectralCentroid.map(v => v.toFixed(2)).join(', ')}`);
            if (results.grid) lines.push(`grid: [${results.grid.length} values]`);
            if (results.ring) lines.push(`ring: [${results.ring.length} values]`);
            if (results.iterHist) lines.push(`hist: [${results.iterHist.length} bins]`);
            
            el.innerHTML = lines.join('<br>');
        }
        
        // Run analysis at configured rate
        function runAnalysis(timestamp) {
            if (timestamp - analysis.lastAnalysisTime < analysis.analysisInterval) return;
            analysis.lastAnalysisTime = timestamp;
            
            // Check if any channel is enabled
            const anyEnabled = Object.values(analysis.channels).some(v => v);
            if (!anyEnabled) return;
            
            const pixels = renderAnalysisBuffer();
            const results = computeAnalysis(pixels);
            outputAnalysis(results);
        }
            
            // Validate numeric inputs
            const num = (x, fallback = 0) => {
                const n = parseFloat(x);
                return isNaN(n) ? fallback : n;
            };
            const int = (x, fallback = 0) => {
                const n = parseInt(x, 10);
                return isNaN(n) ? fallback : n;
            };
            const bool = (x) => x > 0.5 || x === true || x === 'true' || x === 1;
            
            switch(cmd) {
                // Fractal type
                case 'type': setType(int(v) % 6); break;
                case 'mandelbrot': setType(0); break;
                case 'burningship': case 'burning_ship': setType(1); break;
                case 'multibrot': setType(2); break;
                case 'newton': setType(3); break;
                case 'clifford': setType(4); break;
                case 'domain': setType(5); break;
                
                // Navigation
                case 'centerX': case 'center_x': case 'cx': state.centerX = num(v); break;
                case 'centerY': case 'center_y': case 'cy': state.centerY = num(v); break;
                case 'center': state.centerX = num(v); state.centerY = num(v2); break;
                case 'zoom': state.zoom = Math.max(-2, Math.min(45, num(v))); break;
                case 'reset': setType(state.type); break;
                
                // Rendering
                case 'maxIter': case 'max_iter': case 'iterations': case 'iter': 
                    state.maxIter = Math.max(50, Math.min(5000, int(v))); break;
                
                // Colors
                case 'colorScheme': case 'color_scheme': case 'scheme': 
                    state.colorScheme = Math.max(0, Math.min(6, int(v))); break;
                case 'colorOffset': case 'color_offset': case 'offset': 
                    state.colorOffset = num(v) % 1; break;
                case 'colorFreq': case 'color_freq': case 'freq': 
                    state.colorFreq = Math.max(0.1, Math.min(10, num(v))); break;
                
                // Color scheme shortcuts
                case 'classic': state.colorScheme = 0; break;
                case 'fire': state.colorScheme = 1; break;
                case 'ocean': state.colorScheme = 2; break;
                case 'rainbow': state.colorScheme = 3; break;
                case 'grayscale': case 'gray': state.colorScheme = 4; break;
                case 'psychedelic': case 'psych': state.colorScheme = 5; break;
                case 'electric': state.colorScheme = 6; break;
                
                // Julia
                case 'juliaMode': case 'julia_mode': state.juliaMode = bool(v); break;
                case 'juliaX': case 'julia_x': case 'jx': state.juliaX = num(v); break;
                case 'juliaY': case 'julia_y': case 'jy': state.juliaY = num(v); break;
                case 'julia': 
                    if (v2 !== undefined) { state.juliaX = num(v); state.juliaY = num(v2); state.juliaMode = true; }
                    else { state.juliaMode = bool(v); }
                    break;
                case 'julia_on': state.juliaMode = true; break;
                case 'julia_off': state.juliaMode = false; break;
                
                // Multibrot
                case 'power': case 'multibrotPower': case 'multibrot_power': 
                    state.multibrotPower = Math.max(2, Math.min(8, num(v))); break;
                
                // Newton
                case 'newtonPoly': case 'newton_poly': case 'poly': 
                    state.newtonPoly = Math.max(0, Math.min(3, int(v))); break;
                case 'newtonRelax': case 'newton_relax': case 'relax': 
                    state.newtonRelax = Math.max(0.1, Math.min(2, num(v))); break;
                
                // Clifford
                case 'cliffordA': case 'clifford_a': case 'ca': 
                    state.cliffordA = Math.max(-3, Math.min(3, num(v))); state.cliffordDirty = true; break;
                case 'cliffordB': case 'clifford_b': case 'cb': 
                    state.cliffordB = Math.max(-3, Math.min(3, num(v))); state.cliffordDirty = true; break;
                case 'cliffordC': case 'clifford_c': case 'cc': 
                    state.cliffordC = Math.max(-3, Math.min(3, num(v))); state.cliffordDirty = true; break;
                case 'cliffordD': case 'clifford_d': case 'cd': 
                    state.cliffordD = Math.max(-3, Math.min(3, num(v))); state.cliffordDirty = true; break;
                case 'clifford_params': case 'cliff':
                    state.cliffordA = num(v); state.cliffordB = num(v2); 
                    state.cliffordC = num(args[2]); state.cliffordD = num(args[3]); 
                    state.cliffordDirty = true; break;
                
                // Domain
                case 'domainFunc': case 'domain_func': case 'func': 
                    state.domainFunc = Math.max(0, Math.min(9, int(v))); break;
                case 'domainGrid': case 'domain_grid': case 'grid': state.domainGrid = bool(v); break;
                case 'grid_on': state.domainGrid = true; break;
                case 'grid_off': state.domainGrid = false; break;
                
                // Animation
                case 'autoZoom': case 'auto_zoom': case 'autozoom': state.autoZoom = bool(v); break;
                case 'colorCycle': case 'color_cycle': case 'cycle': state.colorCycle = bool(v); break;
                case 'animateParams': case 'animate_params': case 'animate': state.animateParams = bool(v); break;
                case 'animSpeed': case 'anim_speed': case 'speed': 
                    state.animSpeed = Math.max(0.1, Math.min(3, num(v))); break;
                
                // Animation shortcuts
                case 'autozoom_on': state.autoZoom = true; break;
                case 'autozoom_off': state.autoZoom = false; break;
                case 'cycle_on': state.colorCycle = true; break;
                case 'cycle_off': state.colorCycle = false; break;
                case 'animate_on': state.animateParams = true; break;
                case 'animate_off': state.animateParams = false; break;
                
                // =====================================================
                // ANALYSIS COMMANDS
                // =====================================================
                
                // Analysis rate
                case 'analysisRate': case 'analysis_rate': case 'anrate':
                    analysis.rate = Math.max(1, Math.min(60, int(v)));
                    analysis.analysisInterval = 1000 / analysis.rate;
                    break;
                
                // Grid/ring configuration
                case 'analysisGridSize': case 'analysis_grid_size': case 'angridsize':
                    analysis.gridSize = Math.max(2, Math.min(32, int(v)));
                    break;
                case 'analysisRingSamples': case 'analysis_ring_samples': case 'anringsamples':
                    analysis.ringSamples = Math.max(4, Math.min(128, int(v)));
                    break;
                
                // Toggle individual channels
                case 'an_brightness': case 'anbrightness':
                    analysis.channels.brightness = bool(v); break;
                case 'an_escape': case 'anescape': case 'an_escapeRatio':
                    analysis.channels.escapeRatio = bool(v); break;
                case 'an_edge': case 'anedge': case 'an_edgeDensity':
                    analysis.channels.edgeDensity = bool(v); break;
                case 'an_hue': case 'anhue': case 'an_dominantHue':
                    analysis.channels.dominantHue = bool(v); break;
                case 'an_color': case 'ancolor': case 'an_colorBalance':
                    analysis.channels.colorBalance = bool(v); break;
                case 'an_centroid': case 'ancentroid': case 'an_spectralCentroid':
                    analysis.channels.spectralCentroid = bool(v); break;
                case 'an_grid': case 'angrid':
                    analysis.channels.grid = bool(v); break;
                case 'an_columns': case 'ancolumns': case 'an_columnSums':
                    analysis.channels.columnSums = bool(v); break;
                case 'an_rows': case 'anrows': case 'an_rowSums':
                    analysis.channels.rowSums = bool(v); break;
                case 'an_ring': case 'anring':
                    analysis.channels.ring = bool(v); break;
                case 'an_hist': case 'anhist': case 'an_iterHist':
                    analysis.channels.iterHist = bool(v); break;
                case 'an_zoom': case 'anzoom': case 'an_zoomParams':
                    analysis.channels.zoomParams = bool(v); break;
                case 'an_params': case 'anparams': case 'an_fractalParams':
                    analysis.channels.fractalParams = bool(v); break;
                
                // Bulk enable/disable
                case 'an_all_on': case 'analysis_all_on':
                    Object.keys(analysis.channels).forEach(k => analysis.channels[k] = true);
                    break;
                case 'an_all_off': case 'analysis_all_off':
                    Object.keys(analysis.channels).forEach(k => analysis.channels[k] = false);
                    break;
                case 'an_basic_on': // Enable common ones
                    analysis.channels.brightness = true;
                    analysis.channels.escapeRatio = true;
                    analysis.channels.edgeDensity = true;
                    break;
                case 'an_spatial_on': // Enable spatial outputs
                    analysis.channels.grid = true;
                    analysis.channels.columnSums = true;
                    analysis.channels.rowSums = true;
                    analysis.channels.ring = true;
                    break;
                
                // Get analysis state
                case 'getanalysis': case 'get_analysis': case 'dumpanalysis':
                    if (window.max) {
                        window.max.outlet('analysis_config', JSON.stringify(analysis));
                    }
                    console.log('Analysis config:', analysis);
                    break;
                
                // UI
                case 'hideui': case 'hide_ui': document.getElementById('controls').classList.add('hidden'); break;
                case 'showui': case 'show_ui': document.getElementById('controls').classList.remove('hidden'); break;
                case 'toggleui': case 'toggle_ui': document.getElementById('controls').classList.toggle('hidden'); break;
                
                // Get state (outputs to Max)
                case 'getstate': case 'get_state': case 'dump':
                    if (window.max) {
                        window.max.outlet('state', JSON.stringify(state));
                    }
                    console.log('State:', state);
                    break;
                    
                default:
                    console.log('Unknown command:', cmd, args);
            }
            updateUI();
            updateAnalysisUI();
        }

        function setType(t) {
            state.type = Math.max(0, Math.min(5, t));
            const d = defaults[state.type];
            state.centerX = d.x; state.centerY = d.y; state.zoom = d.z;
            if (state.type === 4) state.cliffordDirty = true;
        }
        
        // Update analysis UI elements
        function updateAnalysisUI() {
            const els = {
                anBrightness: 'brightness',
                anEscapeRatio: 'escapeRatio',
                anEdgeDensity: 'edgeDensity',
                anDominantHue: 'dominantHue',
                anColorBalance: 'colorBalance',
                anSpectralCentroid: 'spectralCentroid',
                anGrid: 'grid',
                anColumnSums: 'columnSums',
                anRowSums: 'rowSums',
                anRing: 'ring',
                anIterHist: 'iterHist',
                anZoomParams: 'zoomParams',
                anFractalParams: 'fractalParams'
            };
            
            for (const [elId, channel] of Object.entries(els)) {
                const el = document.getElementById(elId);
                if (el) el.checked = analysis.channels[channel];
            }
            
            const rateEl = document.getElementById('analysisRate');
            if (rateEl) rateEl.value = analysis.rate;
            const rateValEl = document.getElementById('analysisRate-val');
            if (rateValEl) rateValEl.textContent = analysis.rate;
            
            const gridEl = document.getElementById('analysisGridSize');
            if (gridEl) gridEl.value = analysis.gridSize;
            
            const ringEl = document.getElementById('analysisRingSamples');
            if (ringEl) ringEl.value = analysis.ringSamples;
        }

        // =====================================================
        // MAX API INTEGRATION
        // =====================================================
        let maxConnected = false;
        
        if (window.max) {
            maxConnected = true;
            document.getElementById('osc-status').textContent = 'Max: Connected';
            document.getElementById('osc-status').className = 'max';
            
            // Use a more DRY approach for Max bindings
            const commands = [
                'type', 'mandelbrot', 'burningship', 'multibrot', 'newton', 'clifford', 'domain',
                'centerX', 'centerY', 'center', 'cx', 'cy', 'zoom', 'reset',
                'maxIter', 'iterations', 'iter',
                'colorScheme', 'scheme', 'colorOffset', 'offset', 'colorFreq', 'freq',
                'classic', 'fire', 'ocean', 'rainbow', 'grayscale', 'psychedelic', 'electric',
                'juliaMode', 'julia', 'juliaX', 'juliaY', 'jx', 'jy', 'julia_on', 'julia_off',
                'power', 'newtonPoly', 'poly', 'newtonRelax', 'relax',
                'cliffordA', 'cliffordB', 'cliffordC', 'cliffordD', 'ca', 'cb', 'cc', 'cd', 'cliff',
                'domainFunc', 'func', 'domainGrid', 'grid', 'grid_on', 'grid_off',
                'autoZoom', 'autozoom', 'colorCycle', 'cycle', 'animateParams', 'animate', 'animSpeed', 'speed',
                'autozoom_on', 'autozoom_off', 'cycle_on', 'cycle_off', 'animate_on', 'animate_off',
                'hideui', 'showui', 'toggleui', 'getstate', 'dump',
                // Analysis commands
                'analysisRate', 'analysis_rate', 'anrate',
                'analysisGridSize', 'analysis_grid_size', 'angridsize',
                'analysisRingSamples', 'analysis_ring_samples', 'anringsamples',
                'an_brightness', 'anbrightness', 'an_escape', 'anescape', 'an_escapeRatio',
                'an_edge', 'anedge', 'an_edgeDensity', 'an_hue', 'anhue', 'an_dominantHue',
                'an_color', 'ancolor', 'an_colorBalance', 'an_centroid', 'ancentroid', 'an_spectralCentroid',
                'an_grid', 'angrid', 'an_columns', 'ancolumns', 'an_columnSums',
                'an_rows', 'anrows', 'an_rowSums', 'an_ring', 'anring',
                'an_hist', 'anhist', 'an_iterHist', 'an_zoom', 'anzoom', 'an_zoomParams',
                'an_params', 'anparams', 'an_fractalParams',
                'an_all_on', 'analysis_all_on', 'an_all_off', 'analysis_all_off',
                'an_basic_on', 'an_spatial_on',
                'getanalysis', 'get_analysis', 'dumpanalysis'
            ];
            
            commands.forEach(cmd => {
                window.max.bindInlet(cmd, (...args) => handleCommand(cmd, ...args));
            });
            
            console.log('Max API connected');
        }

        // =====================================================
        // UI ELEMENTS
        // =====================================================
        const els = {};
        document.querySelectorAll('input, select').forEach(e => { if(e.id) els[e.id] = e; });

        function updateUI() {
            els.fractalType.value = state.type;
            els.centerX.value = state.centerX;
            els.centerY.value = state.centerY;
            els.zoom.value = state.zoom;
            els.maxIter.value = state.maxIter;
            els.colorScheme.value = state.colorScheme;
            els.colorOffset.value = state.colorOffset;
            els.colorFreq.value = state.colorFreq;
            els.juliaMode.checked = state.juliaMode;
            els.juliaX.value = state.juliaX;
            els.juliaY.value = state.juliaY;
            els.multibrotPower.value = state.multibrotPower;
            els.newtonPoly.value = state.newtonPoly;
            els.newtonRelax.value = state.newtonRelax;
            els.cliffordA.value = state.cliffordA;
            els.cliffordB.value = state.cliffordB;
            els.cliffordC.value = state.cliffordC;
            els.cliffordD.value = state.cliffordD;
            els.domainFunc.value = state.domainFunc;
            els.domainGrid.checked = state.domainGrid;
            els.autoZoom.checked = state.autoZoom;
            els.colorCycle.checked = state.colorCycle;
            els.animateParams.checked = state.animateParams;
            els.animSpeed.value = state.animSpeed;

            document.getElementById('zoom-val').textContent = Math.pow(2, state.zoom).toExponential(1) + 'x';
            document.getElementById('maxIter-val').textContent = state.maxIter;
            document.getElementById('colorOffset-val').textContent = state.colorOffset.toFixed(3);
            document.getElementById('colorFreq-val').textContent = state.colorFreq.toFixed(1);
            document.getElementById('juliaX-val').textContent = state.juliaX.toFixed(3);
            document.getElementById('juliaY-val').textContent = state.juliaY.toFixed(3);
            document.getElementById('multibrotPower-val').textContent = state.multibrotPower.toFixed(2);
            document.getElementById('newtonRelax-val').textContent = state.newtonRelax.toFixed(2);
            document.getElementById('cliffordA-val').textContent = state.cliffordA.toFixed(3);
            document.getElementById('cliffordB-val').textContent = state.cliffordB.toFixed(3);
            document.getElementById('cliffordC-val').textContent = state.cliffordC.toFixed(3);
            document.getElementById('cliffordD-val').textContent = state.cliffordD.toFixed(3);
            document.getElementById('animSpeed-val').textContent = state.animSpeed.toFixed(1);

            document.getElementById('fractal-display').textContent = names[state.type];
            document.getElementById('pos-display').textContent = `(${state.centerX.toFixed(4)}, ${state.centerY.toFixed(4)})`;
            document.getElementById('zoom-display').textContent = Math.pow(2, state.zoom).toExponential(1) + 'x';

            document.getElementById('params-escape').classList.toggle('active', state.type <= 2);
            document.getElementById('params-multibrot').classList.toggle('active', state.type === 2);
            document.getElementById('params-newton').classList.toggle('active', state.type === 3);
            document.getElementById('params-clifford').classList.toggle('active', state.type === 4);
            document.getElementById('params-domain').classList.toggle('active', state.type === 5);
        }

        // Event bindings
        els.fractalType.onchange = () => { setType(parseInt(els.fractalType.value)); updateUI(); };
        els.centerX.oninput = () => { state.centerX = parseFloat(els.centerX.value) || 0; updateUI(); };
        els.centerY.oninput = () => { state.centerY = parseFloat(els.centerY.value) || 0; updateUI(); };
        els.zoom.oninput = () => { state.zoom = parseFloat(els.zoom.value); updateUI(); };
        els.maxIter.oninput = () => { state.maxIter = parseInt(els.maxIter.value); updateUI(); };
        els.colorScheme.onchange = () => { state.colorScheme = parseInt(els.colorScheme.value); updateUI(); };
        els.colorOffset.oninput = () => { state.colorOffset = parseFloat(els.colorOffset.value); updateUI(); };
        els.colorFreq.oninput = () => { state.colorFreq = parseFloat(els.colorFreq.value); updateUI(); };
        els.juliaMode.onchange = () => { state.juliaMode = els.juliaMode.checked; updateUI(); };
        els.juliaX.oninput = () => { state.juliaX = parseFloat(els.juliaX.value); updateUI(); };
        els.juliaY.oninput = () => { state.juliaY = parseFloat(els.juliaY.value); updateUI(); };
        els.multibrotPower.oninput = () => { state.multibrotPower = parseFloat(els.multibrotPower.value); updateUI(); };
        els.newtonPoly.onchange = () => { state.newtonPoly = parseInt(els.newtonPoly.value); updateUI(); };
        els.newtonRelax.oninput = () => { state.newtonRelax = parseFloat(els.newtonRelax.value); updateUI(); };
        
        ['cliffordA','cliffordB','cliffordC','cliffordD'].forEach(k => {
            els[k].oninput = () => { state[k] = parseFloat(els[k].value); state.cliffordDirty = true; updateUI(); };
        });
        
        els.domainFunc.onchange = () => { state.domainFunc = parseInt(els.domainFunc.value); updateUI(); };
        els.domainGrid.onchange = () => { state.domainGrid = els.domainGrid.checked; updateUI(); };
        els.autoZoom.onchange = () => { state.autoZoom = els.autoZoom.checked; updateUI(); };
        els.colorCycle.onchange = () => { state.colorCycle = els.colorCycle.checked; updateUI(); };
        els.animateParams.onchange = () => { state.animateParams = els.animateParams.checked; updateUI(); };
        els.animSpeed.oninput = () => { state.animSpeed = parseFloat(els.animSpeed.value); updateUI(); };

        document.getElementById('reset-view').onclick = () => { setType(state.type); updateUI(); };

        document.querySelectorAll('.julia-preset').forEach(btn => {
            btn.onclick = () => { state.juliaX = parseFloat(btn.dataset.x); state.juliaY = parseFloat(btn.dataset.y); state.juliaMode = true; updateUI(); };
        });

        document.querySelectorAll('.clifford-preset').forEach(btn => {
            btn.onclick = () => {
                state.cliffordA = parseFloat(btn.dataset.a); state.cliffordB = parseFloat(btn.dataset.b);
                state.cliffordC = parseFloat(btn.dataset.c); state.cliffordD = parseFloat(btn.dataset.d);
                state.cliffordDirty = true; updateUI();
            };
        });

        const controls = document.getElementById('controls');
        document.getElementById('toggle-btn').onclick = () => controls.classList.toggle('hidden');

        // Mouse
        let drag = false, lx = 0, ly = 0;
        canvas.onmousedown = e => { if(e.button===0) { drag=true; lx=e.clientX; ly=e.clientY; }};
        canvas.onmousemove = e => {
            if (drag) {
                const s = 1 / Math.pow(2, state.zoom);
                const a = canvas.width / canvas.height;
                state.centerX -= (e.clientX - lx) / canvas.width * 2 * s * a;
                state.centerY += (e.clientY - ly) / canvas.height * 2 * s;
                lx = e.clientX; ly = e.clientY;
                updateUI();
            }
        };
        canvas.onmouseup = () => drag = false;
        canvas.onmouseleave = () => drag = false;
        canvas.onwheel = e => { e.preventDefault(); state.zoom += e.deltaY > 0 ? -0.1 : 0.1; state.zoom = Math.max(-2, Math.min(45, state.zoom)); updateUI(); };
        canvas.ondblclick = e => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width;
            const y = 1 - (e.clientY - rect.top) / rect.height;
            const a = canvas.width / canvas.height;
            const s = 1 / Math.pow(2, state.zoom);
            const cx = (x*2-1) * a * s + state.centerX;
            const cy = (y*2-1) * s + state.centerY;
            if (e.shiftKey && state.type <= 2) { state.juliaX = cx; state.juliaY = cy; state.juliaMode = true; }
            else { state.centerX = cx; state.centerY = cy; }
            updateUI();
        };

        // Touch support
        let lastTouchDist = 0;
        let lastTouchCenter = {x: 0, y: 0};
        
        canvas.ontouchstart = e => {
            e.preventDefault();
            if (e.touches.length === 1) {
                drag = true;
                lx = e.touches[0].clientX;
                ly = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                lastTouchDist = Math.sqrt(dx*dx + dy*dy);
                lastTouchCenter = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
            }
        };
        
        canvas.ontouchmove = e => {
            e.preventDefault();
            if (e.touches.length === 1 && drag) {
                const tx = e.touches[0].clientX;
                const ty = e.touches[0].clientY;
                const s = 1 / Math.pow(2, state.zoom);
                const a = canvas.width / canvas.height;
                state.centerX -= (tx - lx) / canvas.width * 2 * s * a;
                state.centerY += (ty - ly) / canvas.height * 2 * s;
                lx = tx; ly = ty;
                updateUI();
            } else if (e.touches.length === 2) {
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (lastTouchDist > 0) {
                    const scale = dist / lastTouchDist;
                    state.zoom += Math.log2(scale);
                    state.zoom = Math.max(-2, Math.min(45, state.zoom));
                    updateUI();
                }
                lastTouchDist = dist;
            }
        };
        
        canvas.ontouchend = e => {
            e.preventDefault();
            drag = false;
            lastTouchDist = 0;
        };

        // Keyboard
        document.onkeydown = e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            const k = e.key.toLowerCase();
            const panAmount = 0.1 / Math.pow(2, state.zoom);
            
            if (k === 'h') controls.classList.toggle('hidden');
            else if (k === 'r') { setType(state.type); updateUI(); }
            else if (k === 'j') { state.juliaMode = !state.juliaMode; updateUI(); }
            else if (k === ' ') { e.preventDefault(); state.autoZoom = !state.autoZoom; updateUI(); }
            else if (k === 'c') { state.colorCycle = !state.colorCycle; updateUI(); }
            else if (k >= '1' && k <= '6') { setType(parseInt(k)-1); updateUI(); }
            else if (k === '+' || k === '=') { state.zoom = Math.min(45, state.zoom + 0.5); updateUI(); }
            else if (k === '-') { state.zoom = Math.max(-2, state.zoom - 0.5); updateUI(); }
            else if (k === 'arrowleft') { e.preventDefault(); state.centerX -= panAmount; updateUI(); }
            else if (k === 'arrowright') { e.preventDefault(); state.centerX += panAmount; updateUI(); }
            else if (k === 'arrowup') { e.preventDefault(); state.centerY += panAmount; updateUI(); }
            else if (k === 'arrowdown') { e.preventDefault(); state.centerY -= panAmount; updateUI(); }
        };

        // OSC WebSocket
        let ws = null;
        let wsReconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const oscStatus = document.getElementById('osc-status');
        
        function connectOSC() {
            try {
                ws = new WebSocket(els.wsUrl.value);
                ws.onopen = () => { 
                    wsReconnectAttempts = 0;
                    if (!maxConnected) { oscStatus.textContent = 'OSC: Connected'; oscStatus.className = 'connected'; }
                };
                ws.onclose = () => { 
                    if (!maxConnected) { oscStatus.textContent = 'OSC: Disconnected'; oscStatus.className = 'disconnected'; }
                };
                ws.onerror = (err) => {
                    console.error('WebSocket error:', err);
                };
                ws.onmessage = e => {
                    try {
                        const {address, args} = JSON.parse(e.data);
                        const cmd = address.replace('/fractal/', '');
                        handleCommand(cmd, ...args);
                    } catch (err) {
                        console.error('OSC message parse error:', err);
                    }
                };
            } catch (err) {
                console.error('WebSocket connection error:', err);
            }
        }
        
        document.getElementById('osc-connect').onclick = connectOSC;
        document.getElementById('osc-disconnect').onclick = () => { if(ws) ws.close(); };

        // Render loop
        let lastT = 0, frames = 0, fpsT = 0;
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.onresize = resize;
        resize();

        function render(t) {
            const dt = (t - lastT) / 1000;
            lastT = t;
            frames++; fpsT += dt;
            if (fpsT >= 0.5) { document.getElementById('fps-display').textContent = Math.round(frames/fpsT); frames = 0; fpsT = 0; }

            const spd = state.animSpeed;
            if (state.autoZoom) { state.zoom = Math.min(45, state.zoom + 0.02 * spd); updateUI(); }
            if (state.colorCycle) { state.colorOffset = (state.colorOffset + 0.001 * spd) % 1; updateUI(); }
            if (state.animateParams) {
                const tt = t * 0.001 * spd;
                if (state.type <= 2 && state.juliaMode) { state.juliaX = 0.7885 * Math.cos(tt); state.juliaY = 0.7885 * Math.sin(tt); }
                else if (state.type === 2) { state.multibrotPower = 2 + 2 * Math.sin(tt * 0.3); }
                else if (state.type === 3) { state.newtonRelax = 1 + 0.3 * Math.sin(tt); }
                else if (state.type === 4) { 
                    state.cliffordA = -1.4 + 0.5 * Math.sin(tt * 0.7); 
                    state.cliffordB = 1.6 + 0.5 * Math.cos(tt * 0.9); 
                    state.cliffordDirty = true; 
                }
                updateUI();
            }

            if (state.type === 4 && state.cliffordDirty) {
                if (state.animateParams) {
                    scheduleClifordCompute(); // Throttled during animation
                } else {
                    computeClifford(); // Immediate when not animating
                }
            }

            gl.useProgram(prog);
            gl.bindVertexArray(vao);

            gl.uniform2f(u.res, canvas.width, canvas.height);
            gl.uniform2f(u.center, state.centerX, state.centerY);
            gl.uniform1f(u.zoom, Math.pow(2, state.zoom));
            gl.uniform1i(u.maxIter, state.maxIter);
            gl.uniform1i(u.type, state.type);
            gl.uniform1i(u.colorScheme, state.colorScheme);
            gl.uniform1f(u.colorOffset, state.colorOffset);
            gl.uniform1f(u.colorFreq, state.colorFreq);
            gl.uniform1f(u.time, t / 1000);
            gl.uniform1i(u.julia, state.juliaMode ? 1 : 0);
            gl.uniform2f(u.juliaC, state.juliaX, state.juliaY);
            gl.uniform1f(u.power, state.multibrotPower);
            gl.uniform1i(u.newtonPoly, state.newtonPoly);
            gl.uniform1f(u.newtonRelax, state.newtonRelax);
            gl.uniform1f(u.cA, state.cliffordA);
            gl.uniform1f(u.cB, state.cliffordB);
            gl.uniform1f(u.cC, state.cliffordC);
            gl.uniform1f(u.cD, state.cliffordD);
            gl.uniform1i(u.domainFunc, state.domainFunc);
            gl.uniform1i(u.domainGrid, state.domainGrid ? 1 : 0);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, clifTex);
            gl.uniform1i(u.cliffordTex, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            // Run sonification analysis at configured rate
            runAnalysis(t);
            
            requestAnimationFrame(render);
        }

        // Analysis UI event bindings
        const analysisCheckboxes = {
            anBrightness: 'brightness',
            anEscapeRatio: 'escapeRatio',
            anEdgeDensity: 'edgeDensity',
            anDominantHue: 'dominantHue',
            anColorBalance: 'colorBalance',
            anSpectralCentroid: 'spectralCentroid',
            anGrid: 'grid',
            anColumnSums: 'columnSums',
            anRowSums: 'rowSums',
            anRing: 'ring',
            anIterHist: 'iterHist',
            anZoomParams: 'zoomParams',
            anFractalParams: 'fractalParams'
        };
        
        for (const [elId, channel] of Object.entries(analysisCheckboxes)) {
            const el = document.getElementById(elId);
            if (el) {
                el.onchange = () => { analysis.channels[channel] = el.checked; };
            }
        }
        
        const analysisRateEl = document.getElementById('analysisRate');
        if (analysisRateEl) {
            analysisRateEl.oninput = () => {
                analysis.rate = parseInt(analysisRateEl.value) || 30;
                analysis.analysisInterval = 1000 / analysis.rate;
                document.getElementById('analysisRate-val').textContent = analysis.rate;
            };
        }
        
        const analysisGridSizeEl = document.getElementById('analysisGridSize');
        if (analysisGridSizeEl) {
            analysisGridSizeEl.onchange = () => {
                analysis.gridSize = parseInt(analysisGridSizeEl.value) || 8;
            };
        }
        
        const analysisRingSamplesEl = document.getElementById('analysisRingSamples');
        if (analysisRingSamplesEl) {
            analysisRingSamplesEl.onchange = () => {
                analysis.ringSamples = parseInt(analysisRingSamplesEl.value) || 16;
            };
        }

        updateUI();
        updateAnalysisUI();
        computeClifford();
        requestAnimationFrame(render);
    </script>
</body>
</html>
